[manifest]
version = "1.0.0"
priority = 0

# UIElement:draw_pixelated_rect
[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = '''love.graphics.polygon((_type == 'line' or _type == 'line_emboss') and 'line' or "fill", self.pixellated_rect[_type].vertices)'''
position = "at"
payload = '''if self.config.id == 'arrow_badge_color_node' then
    G.SHADERS['arrow_ui_poly']:send('polychrome', {G.TIMERS.REAL/(28), G.TIMERS.REAL})
    G.SHADERS['arrow_ui_poly']:send("time", 123.33412*12.5123152%3000)
    love.graphics.setShader(G.SHADERS['arrow_ui_poly'], G.SHADERS['arrow_ui_poly'])
    love.graphics.polygon((_type == 'line' or _type == 'line_emboss') and 'line' or "fill", self.pixellated_rect[_type].vertices)
    love.graphics.setShader()
elseif self.config.id == 'arrow_rgb_slider' then
    local scale = G.TILESIZE * G.TILESCALE
    G.SHADERS['arrow_rgb_slider']:send('start_x', self.VT.x * scale + self.VT.w/2 * scale)
    G.SHADERS['arrow_rgb_slider']:send('end_x', self.VT.x * scale + self.VT.w/2 * scale + self.VT.w * scale)
    G.SHADERS['arrow_rgb_slider']:send('colour_channel', self.config.ref_table.ref_value)
    G.SHADERS['arrow_rgb_slider']:send('current_color', self.config.ref_table.ref_table)
    love.graphics.setShader(G.SHADERS['arrow_rgb_slider'])
    love.graphics.polygon((_type == 'line' or _type == 'line_emboss') and 'line' or "fill", self.pixellated_rect[_type].vertices)
    love.graphics.setShader()
elseif self.config.id == 'arrow_grad_widget_box' then
    local scale = G.TILESIZE * G.TILESCALE
    local start_x = (self.T.x + self.T.w/2 - 0.15) * scale
    local end_x = (self.T.x + self.T.w/2 + self.T.w - 0.15) * scale
    G.SHADERS['arrow_button_grad']:send('start_x', start_x)
    G.SHADERS['arrow_button_grad']:send('end_x', end_x)

    local color = ArrowAPI.colors.palettes[ArrowAPI.palette_ui_config.open_palette.set].current_palette[ArrowAPI.palette_ui_config.open_palette.idx]

    local array_table = {}
    local size = #color.grad_pos
    for i=1, 8 do
        if i <= size then
            local start_idx = (i - 1) * 3
            array_table[i] = {color[start_idx + 1]/255, color[start_idx + 2]/255, color[start_idx + 3]/255, color.grad_pos[i]}
        else
            array_table[i] = {1, 1, 1, 1}
        end
    end

    G.SHADERS['arrow_button_grad']:send("grad_size", size)
    G.SHADERS['arrow_button_grad']:send("grad_points", unpack(array_table))

    love.graphics.setShader(G.SHADERS['arrow_button_grad'])
    love.graphics.polygon((_type == 'line' or _type == 'line_emboss') and 'line' or "fill", self.pixellated_rect[_type].vertices)
    love.graphics.setShader()
elseif type(self.config.id) == 'string' and (self.config.id:sub(1,20) == 'arrow_palette_button' or self.config.id:sub(1,20) == 'arrow_palette_defaul') then
    local scale = G.TILESIZE * G.TILESCALE
    local start_x = (self.T.x + self.T.w/2 - 0.15) * scale
    local end_x = (self.T.x + self.T.w/2 + self.T.w - 0.15) * scale
    G.SHADERS['arrow_button_grad']:send('start_x', start_x)
    G.SHADERS['arrow_button_grad']:send('end_x', end_x)

    local array_table = {}
    local size = #self.config.colour.grad_pos
    for i=1, 8 do
        if i <= size then
            local start_idx = (i - 1) * 3
            array_table[i] = {self.config.colour[start_idx + 1]/255, self.config.colour[start_idx + 2]/255, self.config.colour[start_idx + 3]/255, self.config.colour.grad_pos[i]}
            if _type == 'emboss' then
                array_table[i] =  darken(array_table[i], self.states.hover.is and 0.5 or 0.3)
            end
        else
            array_table[i] = {1, 1, 1, 1}
        end
    end

    G.SHADERS['arrow_button_grad']:send("grad_size", size)
    G.SHADERS['arrow_button_grad']:send("grad_points", unpack(array_table))

    love.graphics.setShader(G.SHADERS['arrow_button_grad'])
    love.graphics.polygon((_type == 'line' or _type == 'line_emboss') and 'line' or "fill", self.pixellated_rect[_type].vertices)
    love.graphics.setShader()

    if ((self.config.hover and self.states.hover.is) or (self.last_clicked and self.last_clicked > G.TIMERS.REAL - 0.1)) then
        love.graphics.setColor(G.C.UI.HOVER)
        love.graphics.polygon((_type == 'line' or _type == 'line_emboss') and 'line' or "fill", self.pixellated_rect[_type].vertices)
    end
else
    love.graphics.polygon((_type == 'line' or _type == 'line_emboss') and 'line' or "fill", self.pixellated_rect[_type].vertices)
end'''
times = 1
match_indent = true
